# １ 浏览器缓存读取机制

## 1.1  缓存位置

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

### 1.1.1 Service Worker

​	Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，但要求传输协议必须为 **HTTPS**，对图片之类的静态资源不要求，但是图片之类无法读取。

​	Service Worker 的缓存与浏览器其它内建缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存、并且缓存是持续性的。

> 如果 Service Worker 中没命中缓存，重新发起了 fetch 请求，最后不论是从 Memory Cache 中还是从服务器重新获取，最后都会显示从 Service Worker 中获取

### 1.1.2 Memory Cache

​	一般请求后的静态资源都会优先存放在内存中，但是内存是有限的，一般浏览器关闭后内存中缓存也就被释放了

​	内存缓存中有一块重要的资源是 preloader 相关指令下载的资源，如 `<link rel="prefetch">`，它可以一边解析 js/css 文件，一边请求下一个资源

> base64 图片也会被缓存的，内存缓存在缓存资源时并不关心返回资源 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配的也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其它特征做校验

### 1.1.3 Disk Cache

​	绝大部分的缓存资源都来自硬盘存储，它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。

> 对于大文件，大概率直接存储在硬盘中，返之则优先存放在内存
>
> 当前页面某些资源使用率高的话，也会优先存储进硬盘保证下次也能从缓存中读取。

### 1.1.4 Push Cache

​	推送缓存是 HTTP 2 的内容，当以上三种缓存都没命中时才会使用，只在会话期间存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 中只有 5 分钟，同时和内存缓存一样不会严格执行 HTTP 头中的缓存指令。

​	特点：

1. 所有资源都可以被推送和缓存，但是 Edge 和 Safari 支持一般
2. 可以推送 no-cahce 和 no-store 资源 
3. 一旦连接被关闭就释放
4. 多个页面使用同一个 HTTP2 连接时，就可以使用同一个推送缓存
5. 缓存只能被使用一次
6. 浏览器可以拒绝接收已经存在的资源推送
7. 可以给其它域名推送资源