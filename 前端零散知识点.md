# 前端零散知识点

## 比较

```typescript
var a = [1, 2, 3],
	b = [1, 2, 3],
	c = [1, 2, 4]
a == b 	// false
a === b // false
a < b		// true
a > b 	// false
a == !b // true
null == undefined // true
null === undefined // false
```

- 相等和全等比较引用地址
- 引用类型与基础类型比较，引入类型调用`valueOf()`获取值后再进行比较
- 引用类型间的大小比较按字典序比较，比谁的第一项更大，相同再比较下一项
- null和undefined在宽松比较下是相等的，完全比较下是不等的

## instanceof 

- 通过对象上的构造函数指针进行判断

```typescript
null instanceof Object // false, null为空对象，不存在构造函数
function fn(){}
var a = new fn()
a instanceof Object // true
```

## 加减号的运算机制 +

```typescript
'5' + 3 // '53'
'5' - 3 // 2
```

- 加号相比减号会多一步操作：判断左右值是否为字符串，字符串则为拼接

### 一元运算符正负号+-

```typescript
1 +-+++-++- 1 // 0
```

- 加减号又是一元运算符，即数学中的正负号，负负得正

## 一元运算符的特殊用法

- 将函数声明变为表达式

  ```typescript
  + function(){}
  - function(){}
  ~ function(){}
  void function(){}
  ```

## 稀疏数组

- **`Array.prototype.filter`**

  ```typescript
  var ary = [0,1,2];
  ary[10] = 10;
  ary.filter(function(x) { return x === undefined;}); // 返回 []
  ```

  `filter`原码中会判断数组的这个索引值是不是数组的一个属性

- **`Array.prototype.map`**

  ```typescript
  var ary = Array(3);
  ary[0]=2
  ary.map(function(elem) { return '1'; }); // 返回 [1, empty*2]
  ```

  `map`会跳过值为`undefined`的属性

  ```typescript
  Array.prototype.map = function(callback, thisArg) {
  
          var T, A, k;
  
          if (this == null) {
              throw new TypeError(' this is null or not defined');
          }
  
          var O = Object(this);
          var len = O.length >>> 0;
          if (typeof callback !== 'function') {
              throw new TypeError(callback + ' is not a function');
          }
          if (arguments.length > 1) {
              T = thisArg;
          }
          A = new Array(len);
          k = 0;
          while (k < len) {
              var kValue, mappedValue;
              if (k in O) {
                  kValue = O[k];
                  mappedValue = callback.call(T, kValue, k, O);
                  A[k] = mappedValue;
              }
              k++;
          }
          return A;
      };
  ```

## Number的存储

- 以64位(8 byte)存储：`1符号位+11指数位+52实数位`
- 2^53为最大值：`9007199254740992（0x20000000000000）`,超过此值不再精确
- 整数和符点数存储方式都一样

## 运算符优先级 

1. `()`
2. `.`，`?.`，`[]`， `new F()`， `()`
3. `new F`
4. `a++`， `a--` 
5. `!`，`~`， `+a`，`-a`，`++a`，`--a`，`typeof`，`void`，`delete`，`await`
6. `a**b` 
7. `*`，`/`，`%`
8. `a+b`，`a-b`
9. `<<`，`>>`，`>>>`
10. `<`，`<=`，`>`，`>=`，`in`，`instanceof`
11. `==`，`!=`，`===`，`!==`
12. `&` > `^` > `|`
13. `&&` > `||`
14. `?:`
15. `=`，`+=`，`-=`，`*=`，`/=`，`%=`，`<<=`，`>>=`，`>>>=`，`&=`，`^=`，`|=`
16. `yield`，`yield *`
17. `...`
18. `,`

- 辅助记忆
  1. 成员访问`. []`和函数调用`fn()`优先级除`()`最高
  2. `new F`不带括号优先级比成员访问低，`new F()`带括号优先级和成员访问一致，但一般会在成员访问前面，所以先执行
  3. 一元运算优先级`+a， ++a， !a， delete a， typeof a `比二元运算高`a*b，a**b`
  4. 一元运算符执行顺序由右往左，所以`!typeof a`先执行`typeof a`
  5. 二元运算优先级比逻辑运算高`a&&b，a||b`
  6. 逻辑运算优先级比三元运算高`?:`
  7. 三元运算优先级比赋值运算高`a=b，a+=b`
  8. `yield yield * `虽然是一元运算，但比赋值运算优先级低
  9. `...`展开运算符优先级只比逗号运算高
  10. 逗号运算优先级最低

```typescript
'value is ' + ('smtg' === 'smtg') ? 'something' : 'nothing'
// 'value is true' ? 'something' : 'nothing'

1 || fn() && fn() // 返回1，fn()不会执行
1 || true ? 2 : 3 // 返回2，逻辑运算比三元更高，即 1?2:3

function foo(){}
foo.fn = () => 1
foo.prototype.fn = ()=>2
new foo.fn() // 1 ；先执行foo.fn()，再执行new

const str = '123!'
!typeof str === 'string' // typeof str => !'string' => !true => false => ToString 'false' => false
```

## prototype 和 _____proto_____

- prototype 是构造函数专有的属性
- `__proto__`是实例的属性

```typescript
var a = {}
var b = Object.prototype
console.log(a.prototype, a.prototype === b, Object.getPrototypeOf(a) === b) // undefined, false, ture

function fn(){}
var a = fn.prototype // 构造函数的原型，是一个对象 {constructor: f }
var b = Object.getPrototype(fn) // 实例fn的原型,是一个函数 f(){[native code]}
a===b // flase
```

## 函数名称

```typescript
function foo(){}
var oldname = foo.name
foo.name = "bar"
[oldname, foo.name] // ['foo', 'foo']
```

- 函数名称不可改变

## Array.prototype.reduce

- 初始值不提供时，默认为数组第一项

```typescript
[3, 2, 1].reduce(Math.pow) // Math.pow(3, 2), Math.pow(2, 1)
[].reduce(Math.pow) // Error, 空数组会报错
[1].reduce() // Error, 必须提供cb
[1].reduce(Math.pow) // 只有一个初始值时直接返回，不调用回调
```

## String.prototype.replace

- replace回调函数四个参数
  1. 匹配项
  2. reg中子模式的匹配项
  3. 出现的位置
  4. StringObject 本身
- 如果没有子模式匹配的项，第二参数为出现的位置

```typescript
"1 2 3".replace(/\d/g, parseInt) // "1 NaN 3"
/**
	parseInt('1', 0)
	parseInt('2', 2) //二进制不可出现2，返回NaN
	parseInt('3', 4)
*/
```

## parseInt(string, ?radix)

- radix: 2到36的整数（为`0`或者`undefined`和`10`表现一致，为`1`时只会返回NaN）
- `parseInt`常可以与`Number(), Math.ceil()`替换使用，但`Number()`和`Math.ceil()`会隐式调用`valueOf`将其它类型转换为`number`，而`parseInt`不使用`valueOf`，拥有自己的实现

```typescript
parssInt(123.123, 0) // 123
parseInt(123.123, 10) // 123
parseInt(0, 1) // NaN

['1', '2', '3'].map(parseInt) // [('1', 0), ('2', 1), ('3', 2)] => [1, NaN, NaN] 

let obj = {valueOf: ()=>1}
Number(obj) // 1
Math.ceil(obj) // 1
parseInt(obj) // NaN

Number("123A") // NaN
parseInt("123A") // 123
```

## eval

- 将传入的字符串当作JavaScript代码执行
- 如果传入的不是字符串，eval会将参数原封不动地返回
- 间接引用的eval工作在全局作用域下
- **使用Function() 代替 eval()**

```typescript
function f(){}
var parent = Object.getPrototypeOf(f)
f.name // 'f'
parent.name // ''
typeof eval(f.name) // 'function'
typeof eval(parent.name) // 'undefined'
```

## new Date() && Date()

- **new Date(`year`, `?monthIndex:[0-11]`, `?day:[1-31]`, ...)**
- new Date 返回对象
- Date() 返回字符串

```typescript
var a = new Date("2014-03-19")
var b = new Date(2014, 3, 19)
var c = new Date('err') // Invalid Date {} valueOf为NaN
[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()] // [false, false]

new Date() // Fri Sep 04 2020 15:11:54 GMT+0800 (中国标准时间)
Date() // "Fri Sep 04 2020 15:11:54 GMT+0800 (中国标准时间)"

new Date().valueOf() // 1599203639321
Number(new Date()) // 1599203639321
+new Date()	// 1599203639321
-new Date()	// 1599203639321
~~new Date() // 1476020381 位运算的精度不够

```

## Function.length

```typescript
Function.length // 1 
Function // f Function(){[native code]}
new Function().length // 0

function fn(){var a=1}
fn.length // 0 fn和new Function本质上一样
```

## Array.prototype.sort

- 不写回调函数默认使用字典序排序

```typescript
[1, 2, 10, 5].sort() // [1, 10, 2, 5]
[1, 2, 10, 5].sort((a,b)=>a-b) // [1, 2, 5, 10]
```

## 经典闭包问题

```typescript
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1
```

## 隐式转换

- 涉及的运算符：

  1. `+` 
     数字和字符串都可使用， 调用`ToString`, 优先转换为`string`进行处理
  2. `==`
     - `Type(x)` 与`type(y)`相同
       - `💚 undefinded == undefined` 
       - `💚 null == null` 
       - `💚 +0 == -0` 
       - `💔 x，y任意一方为NaN` 
     - `Type(x)` 与`type(y)`不同
       - `💚 undefined == null`
       - `💛 x,y为number和string, string方通过ToNumber()转换后比较`
       - `💛 一方为boolean, boolean通过ToNumber()转换后比较`
       - `💛 x,y为object和number/string, object通过ToPrimitive转换后再比较 `
  3. `- * /` 
     只允许数字使用，调用`ToNumber`, 对象会先调用`ToPrimitive(obj, number)`转换为原始值，再调用`ToNumber`再转一次

- 涉及的转换：

  1. 转换为原始类型值，`ToPrimitive()`
  2. 转换为数字，`ToNumber()`
  3. 转换为字符串，`ToString()`

- **`ToPrimitive(input, ?type)`**

  - `type`为`number`

    1. 原始值直接返回 
    2. 如果是对象，依次尝试使用`valueOf`和`toString`返回原始值
    3. 以上方式都失败，抛出`TypeError`异常

  - `type`为`string`

    1. 原始值直接返回 
    2. 如果是对象，依次尝试使用`toString`和`valueOf`返回原始值
    3. 以上方式都失败，抛出`TypeError`异常

  - 如何决定`type`的值：

    对象为`Date`时`type`为`string`，否则为`number`

- **`valueOf()`**

  每个对象都一定存在`valueOf`和`toString`，因为它是`Object.prototype`的方法，被所有对象继承

  1. 通过`new Number(), new String(), new Boolean()`生成的实例调用`valueOf`，返回其原始值
  2. `Date`的实例返回其时间戳
  3. 其它都返回对象本身，即``this`

- **`toString()`**

  1. `Number, Boolean, String, Array, Date, RegExp, Function`封闭了自己的`toString`方法，返回其相应的字符串，
  2. 其它对象返回对象的类型，如`"[Object Math]", "[Object Object]"`

- **`ToNumber()`**

  | 参数      | 结果                                                         |
  | :-------- | ------------------------------------------------------------ |
  | undefined | Nan                                                          |
  | null      | +0                                                           |
  | boolean   | true =>1,  false => 0                                        |
  | string    | "123" => 123, "123A" => NaN , **'' => 0**                    |
  | object    | 先进行ToPrimitive(obj, number)转换为原始值，再通过ToNumber转换为数字 |

- **`ToString()`**

  | 参数      | 结果                                                         |
  | --------- | ------------------------------------------------------------ |
  | undefined | 'undefined'                                                  |
  | null      | 'null'                                                       |
  | boolean   | 'true', 'false'                                              |
  | number    | '1', '1.23'                                                  |
  | object    | 先进行ToPrimitive(obj, string)转换为原始值，再通过ToString转换为字符串 |

- 例子

  ```typescript
  var a = {
  	valueOf: ()=>1,
  	toString: ()=>123
  }
  true == a // 1 == 1 ture
  ```

  ```typescript
  [] == !{}
  // !{} => false => 0
  // [].toString() => '' => 0
  // 0 == 0 true
  ```

  ```typescript
  const a = {
  	i:1,
  	toString: ()=>a.i++
  }
  a == 1 && a ==2 && a==3 //true
  // a.valueOf() => a => a.toString() => 1
  // a.valueOf() => a => a.toString() => 2
  // a.valueOf() => a => a.toString() => 3
  ```

  ```typescript
  var a = [0]
  if (a){ // a => a.valueOf() => [0] => a.toString() => '0' true
     a == true  // 1 == '0' false
     // true => 1
  }
  ```

  ```typescript
  function fn(){return 20}
  fn + 10 // fn => fn.valueOf() => fn => fn.toString() => 'function fn(){return 20}' + 10 => 'funtion fn(){return 20}10'
  ```

  ```typescript
  [1<2<3,3<2<1] // [true, true]
  ```

## arguments

- ✅ 非严格模式下，arguments与形参变量绑定，一方更新，另一方跟着更新
- ❎ 非严格模式下并与剩余参数、默认参数和解构赋值参数结合使用时，arguments与形参变量相互独立，互不影响
- ❎ 严格模式下，arguments与形参变量相互独立，互不影响

```typescript
  function sidEffecting(ary) {
            ary[0] = ary[2];
				} // 混淆视听的
        function bar(a, b, c) {
            c = 10
            sidEffecting(arguments); //arguments是一个数组，传递的一个地址过去
            return a + b + c;	// 10 + 2 + 10 22
        }
        function demo (arg) {
            arg.name = 'new Name'
        }
        console.log(bar(2, 2, 2)) 
```

```typescript
  function sidEffecting(ary) {
            ary[0] = ary[2];
				} // 混淆视听的
        function bar(a, b, c=4) {
            c = 10
            sidEffecting(arguments); //arguments与a,b,c互不影响
            return a + b + c;	// 2 + 2 + 10 14
        }
        function demo (arg) {
            arg.name = 'new Name'
        }
        console.log(bar(2, 2, 2)) 
```

## void 0

 `void 0` 的值就是`undefined`

## Math.min() 为什么比 Math.max() 大？

- `Math.min()`参数为空时，返回`Infinity`
- `Math.max()`参数为空时，返回`-Infinity`

## [].concat[1,2,3]

- 当数组以此种方式调用时为逗号表达式：即`[（1，2，3）]`
- 所以就是`[].concat[3]`, `Array.prototype.concat[3] => undefined`

## Array.prototype.indexOf

- `indexOf`方法会在内部进行严格判断`===`
  - 注意：`NaN === Nan // false`

```typescript
[1, 2, NaN, 3].indexOf(NaN) // -1

const preNaN = v => isNaN(v) ? 'NaN' : v
[1, 2, NaN, 3].findIndex(v=>preNaN(v) == preNaN(NaN)) // 2
```

## Number.isFinite && isFinite

`isFinite`用于判断一个数字是否是有限数字，如果参数是`NaN, InFinity,-InFinity`会返回`false`，其它返回`true`

`Number.isFinite`相比`isFinite`, 多了只要不是`number`类型，统统返回`false`

- `isFinite`会隐式调用`ToNumber`将转入的参数转换为`number`，所以适用于所有类型
- `Number.isFinite`不会隐式调用 `ToNumber`，所以只适用于`number`

```typescript
Number.isFinite('0') // false
isFinite('0') // '0' ToNumber => 0 => true
```

## 作用域&&优先级&this 综合题

```typescript
function Foo() {
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};	// 覆盖下一句的原getName
function getName() { alert (5);}	// 函数声明提升并赋值

//请写出以下输出结果：
Foo.getName(); 						// 2；函数属性，类似静态方法
getName(); 								// 4；function声明的被后续的var表达式覆盖了
Foo().getName();					// 1；调用Foo(), 修改全局变量getName, 由于调用时没指定this，返回的this即是window
getName();								// 1; window.getName刚被修改了
// 以下是重点
new Foo.getName();				/* 2; new不带括号优先级比成员访问低
																所以执行new(Foo.getName)，而不是new(Foo).getName*/
new Foo().getName();			// 3; new带括号和成员访问一致，从左往右执行，先执行new Foo()，再执行getName()
new new Foo().getName(); 	/* 3; 返回的不再是Foo的实例，而是Foo.getName()的实例
																- 先执行第二个new，即new Foo()，返回Foo的实例
																- 再执行第一个new，即new 实例.getName()
																- 由于new不带括号优先级比成员访问低
																- 所以执行new(实例.getName)
```

## Array.prototype.push

- push返回的是新数组的长度

## 自动分号插入

- 不同于别的运算符（`&&，?:`），表达式可以分多行写，return 后如果不写东西会自动添加`;`

```typescript
function fn(){
	return 
		{a:1}
}
fn() // undefined

function fn1(){
  return true
    ? 1
  	: 2
}
fn1() // 1
```

## let a = b = 0

- 必然是先执行`b=0`，但是`b`没有声明，所以等价于`window.b = 0`

```typescript
function foo() {
	let a = b = 0;
  var c = d = 1;
	a++;
	return a;
}
foo();
typeof a; // undefined
typeof b; // number
typeof c; // undefined
typeof d; // number
```

## {}块语句

```typescript
const length = 4;
const numbers = [];
for (var i = 0; i < length; i++);{ // 块语句常跟在if，for后面执行，但单独的块语句一样会被执行
  numbers.push(i + 1);
}

numbers; // [5]
```

## 严格模式

Es5 的第二种严格模式，要求此后的代码以更加严格的条件下运行。

### 过失错误转为异常

1. 禁止在函数作用域中意外地创建全局变量
2. 使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常
   - 给不可写的属性赋值（数据属性，writeable为false）
   - 给只读属性赋值（访问器属性，只设置了get，未指定set）
   - 给不可扩展的对象新增属性（`Object.preventExtensions()`保护的对象）
3. 试图删除不可删除的属性时会抛出异常，比如`Object.prototype`
4. 要求函数的参数名唯一，否则抛出异常
5. 要求对象的属性名唯一，否则抛出异常
6. 严格模式禁止八进制数字语法，比如`0777`，但在`Es6`中，`0o777`写法受到支持
7. ECMAScript 6中的严格模式禁止设置原始类型值的属性，此前仅仅是忽略，现在会报错

### 简化变量的使用

1. 禁止使用`with`语句， `with`会引起不确定性，导致引擎无法做出优化
2. 严格模式下的 `eval `不再为上层范围(surrounding scope,注:包围eval代码块的范围)引入新变量
3. 严格模式下禁止使用`delete`删除使用`var`声明的变量

### 优化eval和arguments

1. `arguments`不再会跟踪形参变量的变化 
2. `arguments`和`eval`不再可以作为变量名和形参名，并且不可修改
3. 不再支持`arguments.callee`

### 更加安全的JavaScript

1. 禁止使用`函数名.caller`和`函数名.arguments`， `caller`表示最后一次调用此函数的函数
2. `call`和`apply`传递的`this`不再被隐式转换为对象

### 支持未来

1. 新增了一些保留字
2. 禁止在非函数作用域下使用`function` 声明函数

### 注意事项

现在的Js文件都会进行压缩，当一个文件是严格模式时，另一个文件是非严格模式，一但合并，会造成奇奇怪怪的错误

# 123.toString(16) Error

- **`(123).toString(16)`**就不会报错了
- 或者通过装箱**`Object(123).toString(16)`**

# 1<<24 === 2 ** 24