# 1. 盒子模型

## 1.1 组成

1. 内容 **content**
2. 填充 **padding**
3. 边框 **border**
4. 边界 **margin**

## 1.2 分类

1. **IE盒子模型** **border-box**，width，height 包含 content、border、padding

 	2. **W3C**标准盒子模型 **content-box** ，width，height 只包含 content

## 1.3 box-sizing

​	在 IE8+ 的浏览器可以通过 box-sizing 来控制使用的盒子的模型，默认值为 **content-box**

# 2. BFC

​	Block formatting context 块级格式化上下文，是一个独立的布局环境，可以理解为一个容器，在这个容器中布局的元素，不会影响到容器外的元素，外部的元素的布局也不会影响到容器内部的元素
​	**注意，BFC 属于普通流**

**如何创建**

1. 根元素或者包含根元素的元素
2. position = absolute | fixed
3. float != none
4. display = inline-block | flex | inline-flex | table-cell | table-caption
5. overflow != visible 

**其它特性**

1. 同一个 BFC 下会发生 margin 重叠
2. BFC 内部可以包含浮动元素，也就是清除浮动

# 普通流

​	就是元素按在 HTML 文档中的书写顺序自上而下布局，在这个过程中，内联元素水平排列，直到当行被占满。块级元素则会被渲染为一个完整的新行。除非另外指定，否则所有元素默认都是普通流定位。

# 3. IFC

​	Inline formatting context 行内格式化上下文，它有以下布局规则：

1. IFC 内部的盒子会在水平方向，一个接一个地放置
2. 当一行不够时，会自动切换到下一行
3. 行级上下文的高度由内部最高的内联盒子的高度决定
4. IFC 中不能有块级元素，如果插入块级元素（如 p > div），就会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块元素，与 div 垂直排列

##  2.1 行内元素与块级元素的区别

​	**`HTML4`**中，元素被分为两大类：`inline` 及 `block`

- 格式上： 默认情况下，块级元素以新行开始，行内元素不会
- 内容上： 默认情况下，块级元素可以包含行内元素和其它块级元素，而行内元素只能包含行内元素
- 盒子模型属性上：行内元素无法设置 **`height,width`**, 设置 **`margin, padding`**不会影响其它元素，**`line-height`**有效

# 4. GFC

​	GrideLayout formatting context ，风格布局格式化上下文。当对一个元素设置 display 为 grid 时，此元素会获得一个独立的渲染区域

# 5. FFC

​	Flex formatting context，自适应格式化上下文

**如何创建**

​	display = flex | inline-flex
​	

**特性**

1. 渲染为一个块级元素或者行内元素
2. 由伸缩容器和伸缩项目组成，通过设置元素的 display 为 flex 来得到一个伸缩容器
3. 伸缩容器中的每一个子元素都是一个伸缩项目，不受数量限制
4. 通过属性定义伸缩项目应该如何布局

# 3. 层叠上下文

​	stacking context ，我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，**层叠上下文**就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。

## 1. 创建

1. 文档根元素 `<html>`
2. position: absolute | relative & z-index != auto
3. postion: fixed | sticky
4. flex 容器的子元素，且 z-index != auto
5. gird 容器的子元素，且 z-index != auto
6. opacity < 1 
7. transiform | filter | perspective | clip-path | mask | mask-image | mask-border 不为 none
8. -webkit-overflow-scrolling != touch 
   控制在移动端设备上是否有滚动回弹机制
9. will-change 不为空

## 2. 层叠水平

​	stacking level，决定了同一层叠上下文中元素在 z 轴上的显示顺序。**如下图，**

- **DIV#1 z-index 5 在 DIV#4 z-index 6 之上，这是因为 DIV#4 归属于 z-index 3 的 DIV#3**
- **DIV#2 z-index 2 在 DIV#5 z-index 1 之下，这是因为 DIV#5 归属于 z-index 3 的 DIV#3**

![](https://developer.mozilla.org/@api/deki/files/913/=Understanding_zindex_04.png)

## 3. 层叠顺序 

 	stacking order，表示元素发生层叠时有关特定的垂直显示顺序。
	内联盒子要比块级盒子和 float 浮动盒子层叠水平更高是因为文字和图片是重要内容，更需要被显示

![](https://segmentfault.com/img/bVbCN3c)

## 4. 层叠准则

1. 谁大谁在上，当具有明显的层叠水平标识时，如生效的 z-index 属性值，在同一层叠上下文内，层叠水平大的那一个在上
2. 后来者居上，当元素间的层叠水平一致，层叠顺序相同时，在 ＤＯＭ 流中处于后面的元素会覆盖当前元素

# 4. 各个盒子之间的关系

1. 内容区域（contentarea）指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（characterbox）。但是如图片这类的替换元素，显然不是字符盒子，对于这类元素 ，内容区域可以看作元素自身
2. 内联盒子（inlinebox），内联盒子不会让内容成块显示，而是排成一行，这里的内联盒子实际就是指元素的外在例子，用来决定元素是内联还是块级。该盒子又可以细分为“匿名内联盒子”和“内联盒子”两种
3. 行框盒子（linebox），每一行就是一个“行框盒子”，每个“行框盒子”由若干个“内联盒子”组成。只要有内联盒子，就必然有行框盒子，每个行框盒子的高度由最高的内联盒子的高度决定，每个行框盒子的头部会存在一个幽灵空白节点
4. 包含块，由一行一行的“行框盒子”组成

# 5. 幽灵空白节点

​	一种特殊的行内盒子，只在 HTML5 中出现，实际上也是一个盒子，不过是个假想盒，名叫“strut”，中文直译为“支柱”，是一个存在于每个“行框盒子”前面，同时**具有**该元素的字体和行高属性的0 宽度的内联盒。

> Each line box starts with a zero-width inline box with the element’s font and line
> height properties. We call that imaginary box a “strut”.

​	

# 6. 替换元素

​		修改元素的某个属性值，它的呈现内容就可以被替换的元素就称为“替换元素”，例如：`<img>、<object>、<vedio>、<input>、<iframe>、<select>`

**其它特性**

1. 所有替换元素都是内联元素，虽然有的是 `inline`，有的是 `inline-block`
2. 内容的外观不受 CSS 影响，除非其自身暴露的样式接口
3. 替换元素有自己的固有尺寸，如 `<vedio>、<iframe>、<canvas>`为 `300x150`
4. 在很多 CSS 样式上有自己的一套表现规则 ，如 `vertical-algin` 的 `baseline` 的含义就与非替换元素不同
   1. 非替换元素：文字基线（字符的下边缘）
   2. 替换元素：元素的下边缘

**替换元素的尺寸计算**

1. 优先使用 CSS 设置的尺寸
2. 其次使用 HTML 设置的尺寸
3. 如果元素含有固定的宽高比，同时仅设置了宽或者高，则元素依然按照固有的宽高比显示
4. 没有使用 CSS 或者 HTML 指定尺寸，则使用元素的固有尺寸

# 7. 匿名替换元素 content

​	使用 content 属性可以使元素的内容可替换，也就是将非替换元素转为替换元素，类似 `h1::after{content: url('....')}`

**特性**

1. 使用 content 生成的文本无法被选中，无法被屏幕阅读器设备读取，无法被搜索引擎抓取
2. content 生成的内容无法左右 :empty 伪类
3. content 生成的内容无法被 JS 获取

> 部分浏览器可以在其它元素中使用 content 属性，大部分浏览器只允许在伪元素中使用 

# 4. 清除浮动的原因和方法

 	当元素浮动后，不再属于文档流中的普通流，不会影响块级元素的布局（但此时浮动元素已经从普通流中移除了，所以前移是必要的），只会影响行内元素的布局，此时文档流中的普通流就会表现得不同寻常，而当包含块的高度小于浮动元素时，还会发生高度塌陷，影响包含块后面的元素的布局

**清除方法**

1. clear
2. 将父元素独立为一个新 BFC

# 5. clear 清除浮动的原理

```scss
clear: both | left | right | none
```

​	从字面上看，`clear:left` 是清除左浮动，`clear:right` 是清除右浮动，实际上，这种解释并不对，因为浮动一直还在，并没有清除，官方对 clear 的解释是 **元素盒子的边不能和前面的浮动元素相邻**，换言之，clear 是为了清除浮动元素对该元素的影响，而不是清除掉浮动。

```scss
.clear::after{
	content: '';
    display: block; // clear 只对块级元素有效
    clear:both; // 父元素最后一个块不受浮动元素的影响，那么他的定位就是正常的，也就把父元素的高度撑开了
}
```

> ​	由于 float 同一时刻只能为 left 或者 right，并且 clear 对后面的浮动元素是不管的，因此，clear:right 有效的时候，clear:left 必定无效，等同于设置 clear:both；clear:left 有效的时候，clear:right 必定无效，也等同于设置 clear:both。所以在任何时候，clear:both 完全可以代替 clear:right 和 clear: left

# 6. zoom: 1 清除浮动的原理

​	zoom 是 IE 浏览器专有属性，它可以设置或检索对象的绽放比例。解决 IE 下比较奇葩的 BUG，如 margin 重叠、清除浮动、触发 hasLayout等。

​	当设置了 zoom 的值后，所元素的元素就会放大或者缩小，浏览器就会重新计算元素的高度和宽度，从而触发重排，通过这个原理也就解决了 IE 下子元素浮动的时候父元素不随着自动扩大的问题

> zoom 已经出现在 CSS 3.0 的草案中

# 2. 元素居中

## 2.1 宽高固定

1. `margin:auto` 实现水平居中
2. 绝对定位，`top:50%;left:50%` 加上 `负margin`
3. 绝对定位，四个方向的值都为`0`， 设置 `magin:auto`

## 2.2 宽高不定

4. `flex`布局，`justify-content:center;align-items:center`
5. 绝对定位，`top:50%;left:50%` 配合 `transform:translate(-50%, -50%)`

# 3. CSS 实现 三角形

## 3.1 border

​	元素宽高均设为 0 ，只设置 border，然后隐藏掉另外三边，剩下的就是一个三角形

# 4. CSS 实现多列等高

1. flex 布局， align-content:strech

2. display:table-cell，表格的单元格高度相等

3. position:absolute; top:0; bottom:0

4. ```scss
   .box {
       overflow:hidden // 创建 BFC ,清除浮动
   }
   .box > div{
       padding-bottom: 10000px; // 顶开背景色的高度
       margin-bottom:-10000px; // 收缩高度
       float:left; // 水平分布
   }
   ```

   

# 5. 包含块

​	当元素被赋予了百分比值时，它的计算值就是由这个元素的包含块计算而来的，主要包括以下属性：

1. **`height、top、bottom`**的百分比，是通过包含块的 **`height`** 来计算的

> 如果包含块没有指定 height，使包含块的 height 根据它的内容变化 ，而且包含块的 position 为 relative 或者 static ，那么这些值的计算结果为 auto

2. **`width、left、right、padding、margin`**的百分比，是通过包含块的 **`width`** 来计算的

## 5.1 确定包含块

确定一个元素的包含块的过程完全依赖于这个元素的 [`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 属性：

1. 根元素（很多情况下可以看作是 <html>）被称为**初始包含块**，其尺寸等于浏览器视口的大小
2. 如果 position 属性为 `static` 、 `relative` 或 `sticky`，包含块可能由它的最近的祖先**块元素**（比如说inline-block, block 或 list-item元素）的内容区的边缘组成，也可能会建立格式化上下文(比如说 a table container, flex container, grid container, 或者是 the block container 自身)。
3. 如果 position 属性为 `absolute` ，包含块就是由它的最近的 position 的值不是 `static` （也就是值为`fixed`, `absolute`, `relative` 或 `sticky`）的祖先元素的内边距区的边缘组成。
4. 如果 position 属性是 **`fixed`**，在连续媒体的情况下(continuous media)包含块是 [viewport](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport) ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。
5. 如果 position 属性是 `absolute` 或 `fixed`，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：
   1.  [`transform`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform) 或 [`perspective`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective) 的值不是 `none`
   2.  [`will-change`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change) 的值是 `transform` 或 `perspective`
   3.  [`filter`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter) 的值不是 `none` 或 `will-change` 的值是 `filter`(只在 Firefox 下生效).
   4.  [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 的值是 `paint` (例如: `contain: paint;`)

## 5.2 position 为 absolute 与正常流元素的包含块的区别

1. 内联元素也可以作为包含块
2. 一般包含块所在并非父元素，而是祖辈元素中第一个 position 不为 static 的元素
3. 边界是 paddingBox 而不是 content

# CSS + JS 实现全屏滚动

```scss
.parent{
    height:100vh;
    overflow:hidden;
    positon:relative;
}
.parent>.wrapper{
    postion:absolute;
    transition: all .1s ease
}
.wrapper>.child{
    height:100vh
}
```

# 视差滚动

​	多层背景以不同速度移动，形成立体的运动效果，带来非常出色的视觉效果。

**思路1**

1. 多层背景分别设置高度，如近 100vh ，中 75 vh ，远 50 vh。
2. 监听 mousewheel 事件，每次触发时获取 scrollTop，按比例移动三个图层，如近移动 2px，远只需要移动 1px

**思路2**

1. 使用队列保存动画函数，如 `{triggerTop:100, animateFn:()=>{}}`
2. 监听 mousewheel 事件，每次触发时获取 scrollTop，满足条件的动画函数执行并从队列中移除
3. 所有动画都执行完后停止监听

# 响应式布局

​	本质利用媒体查询在不同分辨率使用不同样式，达到不同屏幕大小的设备显示特定的内容。

# margin:auto 的填充规则

1. 一侧 margin 定值，一侧为 auto时，auto 吃完剩余的空间

2. 两侧为 auto 时，两侧平分剩余空间

3. 要求元素具有流动性，比如普通文档流中的块元素默认情况在在水平方向是流动的，所以使用 margin: 0 auto 会填充空隙

4. 而对于绝对定位的元素，默认情况下它是不流动的，没有多余的空间让它填充， margin:auto 无效。但在设置 height + top + bottom 或者 width + left + right 后，它就处于流动状态了。如以下垂直水平居中的实现(宽高固定)

   ```scss
   .center-middle{
   	position: absolute;
       top:0;
   	bottom:0;
       right:0;
       left:0;
       height:100px;
   	width:100px;
   }
   ```

# margin 无效的情况

1. 内联非替换元素的垂直 margin 是无效的，因为元素并非流动（没有多余的空间），所以水平方向的 auto 也不起作用
2. 表格的 `<tr>、<td>`的 margin 是无效的（display 为 table-cell 或者 table-row 的元素同理）
3. 绝对定位元素的 margin:auto 默认是无效的，同理 1 没有多余空间让 auto 起作用 

# border 的特殊性

1. border-width 不支持百分比
2. border-style 默认值为 none，所以必需指定，否则不显示
3. border-color 的默认值为 color 的值，所以可以不指定

# 基线 和 x-height 和 vertical-align

​	基线，即 baseline，字符 x 下边缘就是基线，在布局和排版中常用到这个概念，主要是 line-height 的高度就是两条基线之间的间距，以及 vertical-align 的默认值也是基线。基线是一个非常重要的概念，如下图

​	x-height 就是字符 x 的高度，也就是基线到中线的高度

# vertical-align

​	verical-align 属性影响内联盒子元素在行盒子中的垂直方向的对齐方式（还有表格别忘了），一个行盒子中的多个内联盒子的 vertical-align 值可以不同，默认都为 baseline

- middle ， baseline 到 middleline 的中心线

## 1. 行内块元素的 vertical-align 表现略有不同

1. 行内块元素为空时，或者 overflow 为 visivle，可以将整个元素当作一个文字，基线在块元素下边缘，如下图第一组
2. 行内块元素内有内联元素时，或者 overflow 不为 visivle，此元素的基线就是元素里面的最后一行，如下图第一组和图二

<img src="https://pic2.zhimg.com/80/v2-4a972c9d5df5751cb21bf87f8f0a0079_720w.png" style="zoom: 80%;" />

![](https://ftp.bmp.ovh/imgs/2020/11/484b805401e3e0d3.png)

## 2. vertical-align 的取值

1. 可以为百分比，相对于 line-height 计算
2. 可以为数值，相对于基线向上或者向下偏移

# line-height 的特殊性

## 1. 行距 = line-height - font-size**

​	内联元素的高度由固定高度（font-size）和不固定高度（行距）来确定，line-height 就是通过改变行距来实现的，行距分为两个部分等分在文字的上下方。

## 2. line-height 的取值

1. 为数字时，为其值和 font-size 相乘的值，如 `font-size:1.5` 就是 1.5 倍字体大小
2. 为百分比值时，为其值和 font-size 相乘的值，如 `font-size:150%` 就是 1.5 倍字体大小
3. 为固定值时，保持原意不变

> 无论 line-height 取何值，该内联元素所在的行盒子的高度由行盒子的最高内联元素的高度决定

# clip 裁剪

```scss
position: absolute
clip: rect(top, right, bottom, left) // 4个值都为坐标值，而非距离值 
// 如一个 100*100 的图片
```

# 3. white-space, word-break, word-wrap 的区别和使用

1.  white-space, 控制空白字符的显示

| 是否能发挥作用 | 换行符 | 空格      | 自动换行 | </br>、nbsp; |
| -------------- | ------ | --------- | -------- | ------------ |
| normal         | ×      | ×（合并） | √        | √            |
| nowrap         | ×      | ×（合并） | ×        | √            |
| pre            | √      | √         | ×        | √            |
| pre-wrap       | √      | √         | √        | √            |
| pre-line       | √      | ×（合并） | √        | √            |

2. word-break: normal | break-all | keep-all, 控制单词如何被拆分换行的
3. word-wrap（overflow-wrap）, 控制长度超过一行的单词是否被拆分换行，是`word-break`的补充

**参考**

[彻底搞懂word-break、word-wrap、white-space - Dream_It_Possible - 博客园 (cnblogs.com)](https://www.cnblogs.com/dfyg-xiaoxiao/p/9640422.html)